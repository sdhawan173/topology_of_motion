import math
import numpy as np
import png
from PIL import Image
import glob


def create_blank_image(image_width, image_height):
    """
    Creates color data for a black rectangle
    :param image_width: width of rectangle
    :param image_height: height of rectangle
    :return: generated rectangle
    """
    image_array = []
    for x in range(image_width):
        temp_array = []
        for y in range(image_height):
            temp_pixel = []
            for _ in range(3):
                temp_pixel.append(0)
            temp_array.append(temp_pixel)
        image_array.append(temp_array)
    return image_array


def insert_circle(image_array, image_width, image_height,
                  x_coord, y_coord, circle_radius, circle_color, verbose=False):
    """
    Originally from https://stackoverflow.com/questions/23667646/python-replace-zeros-in-matrix-with-circle-of-ones
    Generates a circle on an array of image data
    :param image_array: image data for png file
    :param image_width: width of output image
    :param image_height: height out output image
    :param x_coord: x-coordinate of center of circle, must be positive integer for array index
    :param y_coord: y-coordinate of center of circle, must be positive integer for array index
    :param circle_radius: radius of cirlce to be drawn
    :param circle_color: array of 3 int values that describes the color of the circle to be drawn
    :param verbose: Boolean to print progress statements
    """
    if verbose:
        print('inserting circle at ({},{})'.format(x_coord, y_coord))
    image_array = np.array(image_array)

    # Create index arrays to z
    I, J = np.meshgrid(np.arange(image_width), np.arange(image_height))

    # calculate distance of all points to centre
    dist = np.sqrt((I - x_coord) ** 2 + (J - y_coord) ** 2)

    # Assign value of 1 to those points where dist<radius:
    image_array[np.where(dist <= circle_radius)] = circle_color

    return np.asarray(image_array)


def convert_to_png(image_array, image_width, image_height):
    """
    converts the image data array into a format that can be saved by the pypng library
    :param image_array: image data for png file
    :param image_width: width of output image
    :param image_height: height out output image
    :return: restructured array in png file format
    """
    png_array = []
    for x in range(image_width):
        temp = []
        for y in range(image_height):
            for z in range(4):
                if z < 3:
                    temp.append(image_array[x][y][z])
                elif z == 3:
                    temp.append(255)
        png_array.append(temp)
    return png_array


def save_png_file(image_name, png_array, image_width, image_height, verbose=False):
    """
    saves png file to the current working directory
    :param image_name: file name of png to be saved
    :param png_array: image data for png file in desired png format
    :param image_width: width of output image
    :param image_height: height of output image
    :param verbose: Boolean to print progress statements
    :return:
    """
    with open(image_name + '.png', 'wb') as data_sample:
        w = png.Writer(image_width, image_height, greyscale=False, alpha='RGBA')
        w.write(data_sample, png_array)
    if verbose:
        print('Saved {}'.format(image_name))


def generate_samples(motion_type, x_points, y_points, image_width, image_height,
                     circle_radius, circle_color, save_png=True):
    """
    Generates a sequence of png files based on x and y points provided.
    :param motion_type: String name of the type of motion the sequence depicts
    :param x_points: list of x values
    :param y_points: list of y values
    :param image_width: width of output image
    :param image_height: height of output image
    :param circle_radius: radius of cirlce to be drawn
    :param circle_color: array of 3 int values that describes the color of the circle to be drawn
    :param save_png: Boolean variable to save each png file or not
    :return: list of all png files generated by x and y points
    """
    image_count = 0
    count_string = ''
    png_data_collection = []
    for x_point, y_point in zip(x_points, y_points):
        image_data = create_blank_image(image_width, image_height)
        image_data = insert_circle(image_data, image_width, image_height, x_point, y_point, circle_radius, circle_color)
        image_string = motion_type + ' motion'
        if image_count < 10:
            count_string = '00' + str(image_count)
        elif image_count < 100:
            count_string = '0' + str(image_count)
        image_string = count_string + ' - ' + image_string
        png_data = convert_to_png(image_data, image_width, image_height)
        png_data_collection.append(png_data)
        if save_png:
            save_png_file(image_string, png_data, image_width, image_height)
        image_count += 1
    return png_data_collection


def generate_gif(motion_type, extension='.png'):
    """
    Creates a gif file from the generated data samples
    """
    file_list = glob.glob('*' + motion_type + '*' + extension)
    img, *imgs = [Image.open(f) for f in sorted(file_list)]
    img.save(fp=motion_type + '.gif', format='GIF', append_images=imgs,
             save_all=True, duration=100, loop=0)


def trig_reparameterize(coord, motion_width):
    return int((motion_width * coord * 0.4) + motion_width / 2)


def clockwise_sort(point, origin=None, reference_vector=None):
    """
    from: "https://stackoverflow.com/questions/41855695/
    sorting-list-of-two-dimensional-coordinates-by-clockwise-angle-using-python"
    :param point: coordinate in the form of [x, y]
    :param origin: origin of point grid, default [0,0]
    :param reference_vector:
    :return: x, y sorted in clockwise order
    """
    if origin is None:
        origin = [0, 0]
    if reference_vector is None:
        reference_vector = [0, 1]
    vector = [point[i] - origin[i] for i in range(2)]
    vector_length = math.hypot(vector[0], vector[1])
    if vector_length == 0:
        return -math.pi, 0
    vector_normalized = [vector[0] / vector_length, vector[1] / vector_length]
    dot_product = sum([vector_normalized[i] * reference_vector[i] for i in range(2)])
    difference_product = reference_vector[1] * vector_normalized[0] - reference_vector[0] * vector_normalized[1]
    angle = math.atan2(difference_product, dot_product)
    if angle < 0:
        return 2 * math.pi + angle, vector_length
    return angle, vector_length


def circle_motion(motion_width, num_points, domain=None):
    if domain is None:
        start_point = 0
        end_point = motion_width
        domain = np.linspace(start_point, end_point, num=num_points)
    point_list = [[x_point, y_point] for x_point, y_point in zip(np.cos(domain), np.sin(domain))]
    point_list = sorted(point_list, key=clockwise_sort)
    x = [trig_reparameterize(point[0], motion_width) for point in point_list]
    y = [trig_reparameterize(point[1], motion_width) for point in point_list]
    return x, y


def sine_motion(domain, width):
    x = domain
    y = [int(trig_reparameterize(y_val, width)) for y_val in np.sin(0.125 * x)]
    return x, y


def horizontal_motion(domain):
    return domain, [50 for _ in range(len(domain))]


def absolute_value(domain):
    y = [int(y_val) for y_val in (domain - max(domain) / 2)]
    y = np.abs(y)
    return y


def diamond(domain):
    leftover_count = 0
    if len(domain) % 4 != 0:
        leftover_count = len(domain) % 4
    down_right_x = [4*x for x in range(0, int(len(domain)//4))]
    down_right_y = [x for x in reversed(down_right_x)]
    up_right_x = [4*x for x in range(int(len(domain)//4), 2*int(len(domain)//4))]
    up_right_y = [x for x in down_right_x]
    up_left_x = [x for x in reversed(up_right_x)]
    up_left_y = [x for x in up_right_x]
    down_left_x = [x for x in reversed(down_right_x)]
    down_left_y = [x for x in reversed(up_left_y)]
    x_list = down_right_x + up_right_x + up_left_x + down_left_x + [down_left_x[-1]]*leftover_count
    y_list = down_right_y + up_right_y + up_left_y + down_left_y + [down_left_y[-1]]*leftover_count
    return x_list, y_list


def vert_zigzag(domain):
    leftover_count = 0
    if len(domain) % 4 != 0:
        leftover_count = len(domain) % 4
    down_right = [int((max(domain) / 2) - 2*x) for x in domain[0:int(len(domain)//4)]]
    up_right = [x for x in reversed(down_right)]
    up_left = [int((max(domain) / 2) - 2*x + max(domain)/2) for x in reversed(domain[0:int(len(domain)//4)])]
    down_left = [x for x in reversed(up_left)]
    y = down_right + up_right + up_left + down_left + [down_left[-1]]*leftover_count
    return y


def no_motion(domain):
    return [50 for _ in range(len(domain))]


def horiz_backforth(domain):
    x = [4*x_val for x_val in range(0, int(len(domain)/2))]
    x = x + [x_val for x_val in reversed(x)]
    y = [50 for _ in domain]
    return x, y


def create_dataset(motion_name, radius=5, color=(255, 0, 0), width=100, height=100, sample_size=50, start=0, end=100):
    domain_values = np.linspace(start, end, num=sample_size)
    # x_values, y_values = circle_motion(width, sample_size)
    # x_values, y_values = sine_motion(domain_values)
    # x_values, y_values = horizontal_motion(domain_values)
    # x_values, y_values = (domain_values, domain_values) #  x=y
    # x_values, y_values = (domain_values, absolute_value(domain_values))
    # x_values, y_values = diamond(domain_values)
    # x_values, y_values = (domain_values, vert_zigzag(domain_values))
    x_values, y_values = horiz_backforth(domain_values)
    # x_values, y_values = (no_motion(domain_values), no_motion(domain_values))
    generate_samples(motion_name, x_values, y_values, width, height, radius, color, save_png=True)
    generate_gif(motion_name)
