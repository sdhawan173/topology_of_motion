import numpy as np
import png
from PIL import Image
import glob


def create_blank_image(image_width, image_height):
    """
    Creates color data for a black rectangle
    :param image_width: width of rectangle
    :param image_height: height of rectangle
    :return: generated rectangle
    """
    image_array = []
    for x in range(image_width):
        temp_array = []
        for y in range(image_height):
            temp_pixel = []
            for _ in range(3):
                temp_pixel.append(0)
            temp_array.append(temp_pixel)
        image_array.append(temp_array)
    return image_array


def insert_circle(image_array, image_width, image_height,
                  x_coord, y_coord, radius, color, verbose=False):
    """
    Originally from https://stackoverflow.com/questions/23667646/python-replace-zeros-in-matrix-with-circle-of-ones
    Generates a circle on an array of image data
    :param image_array: image data for png file
    :param image_width: width of output image
    :param image_height: height out output image
    :param x_coord: x-coordinate of center of circle, must be positive integer for array index
    :param y_coord: y-coordinate of center of circle, must be positive integer for array index
    :param radius: radius of cirlce to be drawn
    :param color: array of 3 int values that describes the color of the circle to be drawn
    :param verbose: Boolean to print progress statements
    """
    if verbose:
        print('inserting circle at ({},{})'.format(x_coord, y_coord))
    image_array = np.array(image_array)

    # Create index arrays to z
    I, J = np.meshgrid(np.arange(image_width), np.arange(image_height))

    # calculate distance of all points to centre
    dist = np.sqrt((I - x_coord) ** 2 + (J - y_coord) ** 2)

    # Assign value of 1 to those points where dist<radius:
    image_array[np.where(dist <= radius)] = color

    return np.asarray(image_array)


def convert_to_png(image_array, image_width, image_height):
    """
    converts the image data array into a format that can be saved by the pypng library
    :param image_array: image data for png file
    :param image_width: width of output image
    :param image_height: height out output image
    :return: restructured array in png file format
    """
    png_array = []
    for x in range(image_width):
        temp = []
        for y in range(image_height):
            for z in range(4):
                if z < 3:
                    temp.append(image_array[x][y][z])
                elif z == 3:
                    temp.append(255)
        png_array.append(temp)
    return png_array


def save_png_file(image_name, png_array, image_width, image_height):
    """
    saves png file to the current working directory
    :param image_name: file name of png to be saved
    :param png_array: image data for png file in desired png format
    :param image_width: width of output image
    :param image_height: height of output image
    :return:
    """
    with open(image_name + '.png', 'wb') as data_sample:
        w = png.Writer(image_width, image_height, greyscale=False, alpha='RGBA')
        w.write(data_sample, png_array)
    print('Saved {}'.format(image_name))


def generate_samples(motion_type, x_points, y_points, image_width, image_height,
                     circle_radius, circle_color, save_png=True):
    """
    Generates a sequence of png files based on x and y points provided.
    :param motion_type: String name of the type of motion the sequence depicts
    :param x_points: list of x values
    :param y_points: list of y values
    :param image_width: width of output image
    :param image_height: height of output image
    :param circle_radius: radius of cirlce to be drawn
    :param circle_color: array of 3 int values that describes the color of the circle to be drawn
    :param save_png: Boolean variable to save each png file or not
    :return: list of all png files generated by x and y points
    """
    image_count = 0
    count_string = ''
    png_data_collection = []
    for x_point, y_point in zip(x_points, y_points):
        image_data = create_blank_image(image_width, image_height)
        image_data = insert_circle(image_data, image_width, image_height, x_point, y_point, circle_radius, circle_color)
        image_string = motion_type + ' motion'
        if image_count < 10:
            count_string = '00' + str(image_count)
        elif image_count < 100:
            count_string = '0' + str(image_count)
        image_string = count_string + ' - ' + image_string
        png_data = convert_to_png(image_data, image_width, image_height)
        png_data_collection.append(png_data)
        if save_png:
            save_png_file(image_string, png_data, image_width, image_height)
        image_count += 1
    return png_data_collection


def generate_gif(motion_type):
    """
    Creates a gif file from the generated data samples
    """
    file_list = glob.glob('*' + motion_type + '*.png')
    img, *imgs = [Image.open(f) for f in sorted(file_list)]
    img.save(fp=motion_type + ' motion.gif', format='GIF', append_images=imgs,
             save_all=True, duration=100, loop=0)


width = 100
height = width
sample_size = 50
motion_name = 'circle (triangular generation)'

start_point = 0
end_point = width
domain = np.linspace(start_point, end_point, num=sample_size)
x_values = [int((width / 3) * (1 + point)) for point in np.cos(domain)]
y_values = [int((width / 3) * (1 + point)) for point in np.sin(domain)]

radius = 5
color = [255, 0, 0]
png_collection = generate_samples(motion_name, x_values, y_values, width, height, radius, color, save_png=False)
# ig.generate_gif(motion_name)
