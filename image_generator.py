import math
import os
import numpy as np
import png
from PIL import Image
import file_code as fc


def create_blank_image(image_width, image_height):
    """
    Creates color data for a black rectangle
    :param image_width: width of rectangle
    :param image_height: height of rectangle
    :return: generated rectangle
    """
    image_array = []
    for x in range(image_width):
        temp_array = []
        for y in range(image_height):
            temp_pixel = []
            for _ in range(3):
                temp_pixel.append(0)
            temp_array.append(temp_pixel)
        image_array.append(temp_array)
    return image_array


def insert_circle(image_array, image_width, image_height,
                  x_coord, y_coord, circle_radius, circle_color, verbose=False):
    """
    Originally from https://stackoverflow.com/questions/23667646/python-replace-zeros-in-matrix-with-circle-of-ones
    Generates a circle on an array of image data
    :param image_array: image data for png file
    :param image_width: width of output image
    :param image_height: height out output image
    :param x_coord: x-coordinate of center of circle, must be positive integer for array index
    :param y_coord: y-coordinate of center of circle, must be positive integer for array index
    :param circle_radius: radius of cirlce to be drawn
    :param circle_color: array of 3 int values that describes the color of the circle to be drawn
    :param verbose: Boolean to print progress statements
    """
    if verbose:
        print('inserting circle at ({},{})'.format(x_coord, y_coord))
    image_array = np.array(image_array)

    # Create index arrays to z
    I, J = np.meshgrid(np.arange(image_width), np.arange(image_height))

    # calculate distance of all points to centre
    dist = np.sqrt((I - x_coord) ** 2 + (J - y_coord) ** 2)

    # Assign value of 1 to those points where dist<radius:
    image_array[np.where(dist <= circle_radius)] = circle_color

    return np.asarray(image_array)


def convert_to_png(image_array, image_width, image_height):
    """
    converts the image data array into a format that can be saved by the pypng library
    :param image_array: image data for png file
    :param image_width: width of output image
    :param image_height: height out output image
    :return: restructured array in png file format
    """
    png_array = []
    for x in range(image_width):
        temp = []
        for y in range(image_height):
            for z in range(4):
                if z < 3:
                    temp.append(image_array[x][y][z])
                elif z == 3:
                    temp.append(255)
        png_array.append(temp)
    return png_array


def save_png_file(image_name, png_array, image_width, image_height, verbose=False):
    """
    saves png file to the current working directory
    :param image_name: file name of png to be saved
    :param png_array: image data for png file in desired png format
    :param image_width: width of output image
    :param image_height: height of output image
    :param verbose: Boolean to print progress statements
    :return:
    """
    with open(image_name + '.png', 'wb') as data_sample:
        w = png.Writer(image_width, image_height, greyscale=False, alpha='RGBA')
        w.write(data_sample, png_array)
    if verbose:
        print('Saved {}'.format(image_name))


def generate_samples(motion_type, x_points, y_points, width, height,
                     circle_radius, circle_color):
    """
    Generates a sequence of png files based on x and y points provided.
    :param motion_type: String name of the type of motion the sequence depicts
    :param x_points: list of x values
    :param y_points: list of y values
    :param width: width of output image
    :param height: height of output image
    :param circle_radius: radius of cirlce to be drawn
    :param circle_color: array of 3 int values that describes the color of the circle to be drawn
    :return: list of all png files generated by x and y points
    """
    # delete previous samples
    dir_index = None
    sample_dirs = fc.get_sample_dirs()
    for index, sample_dir in enumerate(sample_dirs):
        if sample_dir.__contains__(motion_type):
            dir_index = index
            break
    file_list = fc.get_image_file_names(sample_dirs, dir_index, search_term=motion_type)
    for image_file in file_list:
        os.remove(os.getcwd() + '/' + sample_dirs[dir_index] + '/' + image_file)

    image_count = 0
    count_string = ''
    png_data_collection = []
    for x_point, y_point in zip(x_points, y_points):
        image_data = create_blank_image(width, height)
        image_data = insert_circle(image_data, width, height, x_point, y_point, circle_radius, circle_color)
        image_string = motion_type
        if image_count < 10:
            count_string = '00' + str(image_count)
        elif image_count < 100:
            count_string = '0' + str(image_count)
        elif image_count > 100:
            count_string = str(image_count)
        image_string = image_string + ' - ' + count_string
        png_data = convert_to_png(image_data, width, height)
        png_data_collection.append(png_data)
        dir_index = None
        sample_dirs = fc.get_sample_dirs()
        for index, sample_dir in enumerate(sample_dirs):
            if sample_dir.__contains__(motion_type):
                dir_index = index
                break
        save_png_file(os.getcwd() + '/' + sample_dirs[dir_index] + '/' + image_string, png_data, width, height)
        image_count += 1
    return png_data_collection


def generate_gif(motion_type):
    """
    Creates a gif file from the generated data samples
    """
    dir_index = None
    sample_dirs = fc.get_sample_dirs()
    for index, sample_dir in enumerate(sample_dirs):
        if sample_dir.__contains__(motion_type):
            dir_index = index
            break
    file_list = fc.get_image_file_names(sample_dirs, dir_index, search_term=motion_type)
    save_path = os.getcwd() + '/' + sample_dirs[dir_index] + '/'
    img, *imgs = [Image.open(save_path + f) for f in file_list]
    img.save(fp=save_path + motion_type + '.gif', format='GIF', append_images=imgs,
             save_all=True, duration=10, loop=0)
    print('gif saved to {}'.format(save_path + motion_type + '.gif'))


def trig_reparameterize(coord, motion_width):
    return int((motion_width * coord * 0.4) + motion_width / 2)


def clockwise_sort(point, origin=None, reference_vector=None):
    """
    from: "https://stackoverflow.com/questions/41855695/
    sorting-list-of-two-dimensional-coordinates-by-clockwise-angle-using-python"
    :param point: coordinate in the form of [x, y]
    :param origin: origin of point grid, default [0,0]
    :param reference_vector:
    :return: x, y sorted in clockwise order
    """
    if origin is None:
        origin = [0, 0]
    if reference_vector is None:
        reference_vector = [0, 1]
    vector = [point[i] - origin[i] for i in range(2)]
    vector_length = math.hypot(vector[0], vector[1])
    if vector_length == 0:
        return -math.pi, 0
    vector_normalized = [vector[0] / vector_length, vector[1] / vector_length]
    dot_product = sum([vector_normalized[i] * reference_vector[i] for i in range(2)])
    difference_product = reference_vector[1] * vector_normalized[0] - reference_vector[0] * vector_normalized[1]
    angle = math.atan2(difference_product, dot_product)
    if angle < 0:
        return 2 * math.pi + angle, vector_length
    return angle, vector_length


def circle_motion(motion_width, num_points, domain=None):
    if domain is None:
        start_point = 0
        end_point = motion_width
        domain = np.linspace(start_point, end_point, num=num_points)
    point_list = [[x_point, y_point] for x_point, y_point in zip(np.cos(domain), np.sin(domain))]
    point_list = sorted(point_list, key=clockwise_sort)
    x = [trig_reparameterize(point[0], motion_width) for point in point_list]
    y = [trig_reparameterize(point[1], motion_width) for point in point_list]
    return x, y


def sine_motion(domain, width):
    x = domain
    y = [int(trig_reparameterize(y_val, width)) for y_val in np.sin(0.5 * x)]
    return x, y


def sinebackforth(domain, width):
    x = [x_val for x_val in domain] + [x_val for x_val in reversed(domain)]
    y1 = [int(trig_reparameterize(y_val, width)) for y_val in np.sin(0.5 * domain)]
    y2 = [y_val for y_val in reversed(y1)]
    y = y1 + y2
    return x, y


def horizontal_motion(domain, width):
    return domain, [width/2 for _ in range(len(domain))]


def absolute_value(domain):
    y = [int(y_val) for y_val in (domain - max(domain) / 2)]
    y = np.abs(y)
    return y


def diamond(domain):
    leftover_count = 0
    if len(domain) % 4 != 0:
        leftover_count = len(domain) % 4
    down_right_x = [x for x in range(0, int(len(domain) // 4))]
    down_right_y = [x for x in reversed(down_right_x)]
    up_right_x = [x for x in range(int(len(domain) // 4), 2 * (int(len(domain) // 4)))]
    up_right_y = [x for x in down_right_x]
    up_left_x = [x for x in reversed(up_right_x)]
    up_left_y = [x for x in up_right_x]
    down_left_x = [x for x in reversed(down_right_x)]
    down_left_y = [x for x in reversed(up_left_y)]
    x_list = down_right_x + up_right_x + up_left_x + down_left_x + [down_left_x[-1]] * leftover_count
    y_list = down_right_y + up_right_y + up_left_y + down_left_y + [down_left_y[-1]] * leftover_count
    return x_list, y_list


def vert_zigzag(domain):
    leftover_count = 0
    if len(domain) % 4 != 0:
        leftover_count = len(domain) % 4
    down_right = [int((max(domain) / 2) - 2 * x) for x in domain[0:int(len(domain) // 4)]]
    up_right = [x for x in reversed(down_right)]
    up_left = [int((max(domain) / 2) - 2 * x + max(domain) / 2) for x in reversed(domain[0:int(len(domain) // 4)])]
    down_left = [x for x in reversed(up_left)]
    y = down_right + up_right + up_left + down_left + [down_left[-1]] * leftover_count
    return y


def no_motion(domain, width):
    return [width / 2 for _ in range(len(domain))]


def horiz_backforth(width, frame_num):
    x = [int(x_val) for x_val in np.linspace(0, width, num=int(frame_num / 2))]
    x = x + [int(x_val) for x_val in reversed(x)]
    y = [width/2 for _ in x]
    return x, y


radius = 10
color = (255, 0, 0)
len1 = 100
len2 = len1
sample_size = 200
start = 0
end = len1
domain_values = np.linspace(start, end, num=sample_size)
input_list = [
    # ['circle (radial generation)', circle_motion(len1, sample_size, domain=domain_values)],
    # ['sine wave motion', sine_motion(domain_values, len1)],
    # ['linear horizontal motion', horizontal_motion(domain_values, len1)],
    # ['linear diagonal motion', (domain_values, domain_values)],
    # ['absolute value motion', (domain_values, absolute_value(domain_values))],
    # ['diamond motion', diamond(domain_values)],
    # ['vertical zigzag motion', (domain_values, vert_zigzag(domain_values))],
    # ['horizontal back and forth motion', horiz_backforth(len1, sample_size)],
    # ['stationary dot, no motion', (no_motion(domain_values, len1), no_motion(domain_values, len1))]
    ['sine wave back and forth motion', sinebackforth(domain_values, len1)]
]
for data in input_list:
    motion = data[0]
    x_values, y_values = data[1]
    generate_samples(motion, x_values, y_values, len1, len2, radius, color)
    generate_gif(motion)
